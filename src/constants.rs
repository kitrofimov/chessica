// Generated by `bin/rook_magics_gen.rs` and `bin/bishop_magics_gen.rs`
mod rook_magics;
mod bishop_magics;

pub use rook_magics::*;
pub use bishop_magics::*;
use super::utility::bit;

const fn generate_knight_attack(square: u8) -> u64 {
    let bb = 1u64 << square;

    let no_ab = bb & !(FILE_A | FILE_B);
    let no_gh = bb & !(FILE_G | FILE_H);
    let no_12 = bb & !(RANK[1] | RANK[2]);
    let no_78 = bb & !(RANK[7] | RANK[8]);

    ((no_ab & !RANK[8]) << 6)  | // left-left-up
    ((no_ab & !RANK[1]) >> 10) | // left-left-down
    ((no_gh & !RANK[8]) << 10) | // right-right-up
    ((no_gh & !RANK[1]) >> 6)  | // right-right-down
    ((no_12 & !FILE_H) >> 15)  | // right-down-down
    ((no_12 & !FILE_A) >> 17)  | // left-down-down
    ((no_78 & !FILE_H) << 17)  | // right-up-up
    ((no_78 & !FILE_A) << 15)    // left-up-up
}

const fn generate_king_attack(square: u8) -> u64 {
    let bb = 1u64 << square;

    let no_a = bb & !FILE_A;
    let no_h = bb & !FILE_H;
    let no_1 = bb & !RANK[1];
    let no_8 = bb & !RANK[8];

    (no_a >> 1)        | // right
    (no_h << 1)        | // left
    (no_1 >> 8)        | // down
    (no_8 << 8)        | // up
    (no_a & no_8) << 7 | // up-left
    (no_h & no_8) << 9 | // up-right
    (no_a & no_1) >> 9 | // down-left
    (no_h & no_1) >> 7   // down-right
}

pub static KNIGHT_ATTACKS: [u64; 64] = {
    let mut table = [0u64; 64];
    let mut i = 0;
    while i < 64 {
        table[i] = generate_knight_attack(i as u8);
        i += 1;
    }
    table
};

pub static KING_ATTACKS: [u64; 64] = {
    let mut table = [0u64; 64];
    let mut i = 0;
    while i < 64 {
        table[i] = generate_king_attack(i as u8);
        i += 1;
    }
    table
};

pub static ROOK_MASKS: [u64; 64] = {
    let mut table = [0u64; 64];

    table[0]  = (RANK[1] | FILE_A) & !(RANK[8] | FILE_H | (1 << 0));  // a1
    table[7]  = (RANK[1] | FILE_H) & !(RANK[8] | FILE_A | (1 << 7));  // h1
    table[56] = (RANK[8] | FILE_A) & !(RANK[1] | FILE_H | (1 << 56)); // a8
    table[63] = (RANK[8] | FILE_H) & !(RANK[1] | FILE_A | (1 << 63)); // h8

    let mut i = 0;
    let edges = FILE_A | FILE_H | RANK[1] | RANK[8];
    while i < 64 {
        if i == 0 || i == 7 || i == 56 || i == 63 {
            i += 1;
            continue;
        }

        let rank = i / 8;
        let file = i % 8;

        let bb = 1 << i;
        table[i] = if bb & FILE_A != 0 {  // if on file A
            (RANK[rank + 1] | FILE_A) & !bb & !FILE_H & !RANK[1] & !RANK[8]
        } else if bb & FILE_H != 0 {  // if on file H
            (RANK[rank + 1] | FILE_H) & !bb & !FILE_A & !RANK[1] & !RANK[8]
        } else if bb & RANK[1] != 0 {  // if on rank 1
            (RANK[1] | FILE[file + 1]) & !bb & !RANK[8] & !FILE_A & !FILE_H
        } else if bb & RANK[8] != 0 {  // if on rank 8
            (RANK[8] | FILE[file + 1]) & !bb & !RANK[1] & !FILE_A & !FILE_H
        } else {  // if in the middle
            (RANK[rank + 1] | FILE[file + 1]) & !bb & !edges
        };

        i += 1;
    }

    table
};

pub static BISHOP_MASKS: [u64; 64] = {
    let mut masks = [0u64; 64];
    let mut sq = 0;

    while sq < 64 {
        let rank = sq / 8;
        let file = sq % 8;
        let mut mask = 0u64;

        // top-right
        let mut tr = 1;
        while rank + tr < 7 && file + tr < 7 {
            mask |= bit((rank + tr) * 8 + (file + tr));
            tr += 1;
        }

        // top-left
        let mut tl = 1;
        while rank + tl < 7 && file > tl {
            mask |= bit((rank + tl) * 8 + (file - tl));
            tl += 1;
        }

        // bottom-right
        let mut br = 1;
        while rank > br && file + br < 7 {
            mask |= bit((rank - br) * 8 + (file + br));
            br += 1;
        }

        // bottom-left
        let mut bl = 1;
        while rank > bl && file >= bl {
            mask |= bit((rank - bl) * 8 + (file - bl));
            bl += 1;
        }

        masks[sq] = mask;
        sq += 1;
    }
    masks
};

pub const RANK: [u64; 8+1] = [
    0,                  // Rank 0 (unused, for convenience)
    0x00000000000000FF, // Rank 1
    0x000000000000FF00, // Rank 2
    0x0000000000FF0000, // Rank 3
    0x00000000FF000000, // Rank 4
    0x000000FF00000000, // Rank 5
    0x0000FF0000000000, // Rank 6
    0x00FF000000000000, // Rank 7
    0xFF00000000000000, // Rank 8
];

pub const FILE_A: u64 = 0x0101010101010101; // 0b00000001...
pub const FILE_B: u64 = 0x0202020202020202; // 0b00000010...
pub const FILE_C: u64 = 0x0404040404040404; // 0b00000100...
pub const FILE_D: u64 = 0x0808080808080808; // 0b00001000...
pub const FILE_E: u64 = 0x1010101010101010; // 0b00010000...
pub const FILE_F: u64 = 0x2020202020202020; // 0b00100000...
pub const FILE_G: u64 = 0x4040404040404040; // 0b01000000...
pub const FILE_H: u64 = 0x8080808080808080; // 0b10000000...

pub const FILE: [u64; 8+1] = [
    0, // File 0 (unused, for convenience)
    FILE_A, FILE_B, FILE_C, FILE_D,
    FILE_E, FILE_F, FILE_G, FILE_H,
];
