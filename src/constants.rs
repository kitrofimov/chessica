// Generated by `bin/rook_magics_gen.rs` and `bin/bishop_magics_gen.rs`
mod rook_magics;
mod bishop_magics;

pub use rook_magics::*;
pub use bishop_magics::*;
use super::utility::bit;


pub const NAME: &str = "chess-engine";
pub const AUTHOR: &str = "Kirill Trofimov";


const fn generate_knight_attack(square: u8) -> u64 {
    let bb = 1u64 << square;

    let no_ab = bb & !(FILE_A | FILE_B);
    let no_gh = bb & !(FILE_G | FILE_H);
    let no_12 = bb & !(RANK[1] | RANK[2]);
    let no_78 = bb & !(RANK[7] | RANK[8]);

    ((no_ab & !RANK[8]) << 6)  | // left-left-up
    ((no_ab & !RANK[1]) >> 10) | // left-left-down
    ((no_gh & !RANK[8]) << 10) | // right-right-up
    ((no_gh & !RANK[1]) >> 6)  | // right-right-down
    ((no_12 & !FILE_H) >> 15)  | // right-down-down
    ((no_12 & !FILE_A) >> 17)  | // left-down-down
    ((no_78 & !FILE_H) << 17)  | // right-up-up
    ((no_78 & !FILE_A) << 15)    // left-up-up
}

const fn generate_king_attack(square: u8) -> u64 {
    let bb = 1u64 << square;

    let no_a = bb & !FILE_A;
    let no_h = bb & !FILE_H;
    let no_1 = bb & !RANK[1];
    let no_8 = bb & !RANK[8];

    (no_a >> 1)        | // right
    (no_h << 1)        | // left
    (no_1 >> 8)        | // down
    (no_8 << 8)        | // up
    (no_a & no_8) << 7 | // up-left
    (no_h & no_8) << 9 | // up-right
    (no_a & no_1) >> 9 | // down-left
    (no_h & no_1) >> 7   // down-right
}

pub static PAWN_ATTACKS_WHITE: [u64; 64] = {
    let mut table = [0u64; 64];
    let mut sq = 0;
    while sq < 64 {
        let rank = sq / 8;
        let file = sq % 8;
        let mut attacks = 0u64;

        if file > 0 && rank < 7 {
            attacks |= 1u64 << (sq + 7);
        }
        if file < 7 && rank < 7 {
            attacks |= 1u64 << (sq + 9);
        }

        table[sq] = attacks;
        sq += 1;
    }
    table
};

pub static PAWN_ATTACKS_BLACK: [u64; 64] = {
    let mut table = [0u64; 64];
    let mut sq = 0;
    while sq < 64 {
        let rank = sq / 8;
        let file = sq % 8;
        let mut attacks = 0u64;

        if file > 0 && rank > 0 {
            attacks |= 1u64 << (sq - 9);
        }
        if file < 7 && rank > 0 {
            attacks |= 1u64 << (sq - 7);
        }

        table[sq] = attacks;
        sq += 1;
    }
    table
};

pub static KNIGHT_ATTACKS: [u64; 64] = {
    let mut table = [0u64; 64];
    let mut i = 0;
    while i < 64 {
        table[i] = generate_knight_attack(i as u8);
        i += 1;
    }
    table
};

pub static KING_ATTACKS: [u64; 64] = {
    let mut table = [0u64; 64];
    let mut i = 0;
    while i < 64 {
        table[i] = generate_king_attack(i as u8);
        i += 1;
    }
    table
};

pub static ROOK_MASKS: [u64; 64] = {
    let mut table = [0u64; 64];

    table[0]  = (RANK[1] | FILE_A) & !(RANK[8] | FILE_H | (1 << 0));  // a1
    table[7]  = (RANK[1] | FILE_H) & !(RANK[8] | FILE_A | (1 << 7));  // h1
    table[56] = (RANK[8] | FILE_A) & !(RANK[1] | FILE_H | (1 << 56)); // a8
    table[63] = (RANK[8] | FILE_H) & !(RANK[1] | FILE_A | (1 << 63)); // h8

    let mut i = 0;
    let edges = FILE_A | FILE_H | RANK[1] | RANK[8];
    while i < 64 {
        if i == 0 || i == 7 || i == 56 || i == 63 {
            i += 1;
            continue;
        }

        let rank = i / 8;
        let file = i % 8;

        let bb = 1 << i;
        table[i] = if bb & FILE_A != 0 {  // if on file A
            (RANK[rank + 1] | FILE_A) & !bb & !FILE_H & !RANK[1] & !RANK[8]
        } else if bb & FILE_H != 0 {  // if on file H
            (RANK[rank + 1] | FILE_H) & !bb & !FILE_A & !RANK[1] & !RANK[8]
        } else if bb & RANK[1] != 0 {  // if on rank 1
            (RANK[1] | FILE[file + 1]) & !bb & !RANK[8] & !FILE_A & !FILE_H
        } else if bb & RANK[8] != 0 {  // if on rank 8
            (RANK[8] | FILE[file + 1]) & !bb & !RANK[1] & !FILE_A & !FILE_H
        } else {  // if in the middle
            (RANK[rank + 1] | FILE[file + 1]) & !bb & !edges
        };

        i += 1;
    }

    table
};

pub static BISHOP_MASKS: [u64; 64] = {
    let mut masks = [0u64; 64];
    let mut sq = 0;

    while sq < 64 {
        let rank = sq / 8;
        let file = sq % 8;
        let mut mask = 0u64;

        // top-right
        let mut tr = 1;
        while rank + tr < 7 && file + tr < 7 {
            mask |= bit((rank + tr) * 8 + (file + tr));
            tr += 1;
        }

        // top-left
        let mut tl = 1;
        while rank + tl < 7 && file > tl {
            mask |= bit((rank + tl) * 8 + (file - tl));
            tl += 1;
        }

        // bottom-right
        let mut br = 1;
        while rank > br && file + br < 7 {
            mask |= bit((rank - br) * 8 + (file + br));
            br += 1;
        }

        // bottom-left
        let mut bl = 1;
        while rank > bl && file >= bl {
            mask |= bit((rank - bl) * 8 + (file - bl));
            bl += 1;
        }

        masks[sq] = mask;
        sq += 1;
    }
    masks
};

pub const RANK: [u64; 8+1] = [
    0,                  // Rank 0 (unused, for convenience)
    0x00000000000000FF, // Rank 1
    0x000000000000FF00, // Rank 2
    0x0000000000FF0000, // Rank 3
    0x00000000FF000000, // Rank 4
    0x000000FF00000000, // Rank 5
    0x0000FF0000000000, // Rank 6
    0x00FF000000000000, // Rank 7
    0xFF00000000000000, // Rank 8
];

pub const FILE_A: u64 = 0x0101010101010101; // 0b00000001...
pub const FILE_B: u64 = 0x0202020202020202; // 0b00000010...
pub const FILE_C: u64 = 0x0404040404040404; // 0b00000100...
pub const FILE_D: u64 = 0x0808080808080808; // 0b00001000...
pub const FILE_E: u64 = 0x1010101010101010; // 0b00010000...
pub const FILE_F: u64 = 0x2020202020202020; // 0b00100000...
pub const FILE_G: u64 = 0x4040404040404040; // 0b01000000...
pub const FILE_H: u64 = 0x8080808080808080; // 0b10000000...

pub const FILE: [u64; 8+1] = [
    0, // File 0 (unused, for convenience)
    FILE_A, FILE_B, FILE_C, FILE_D,
    FILE_E, FILE_F, FILE_G, FILE_H,
];


#[cfg(test)]
mod tests {
    use super::*;

    // List of squares to bitboard
    fn sq_to_bb(lst: &[u8]) -> u64 {
        lst.iter().fold(0u64, |s, &a| s | bit(a.into()))
    }

    // See https://www.chessprogramming.org/File:Lerf.JPG

    #[test]
    fn white_pawn_attack_table() {
        assert_eq!(PAWN_ATTACKS_WHITE[10], sq_to_bb(&[17, 19]));
        assert_eq!(PAWN_ATTACKS_WHITE[21], sq_to_bb(&[28, 30]));
        assert_eq!(PAWN_ATTACKS_WHITE[31], sq_to_bb(&[38]));
        assert_eq!(PAWN_ATTACKS_WHITE[35], sq_to_bb(&[42, 44]));
        assert_eq!(PAWN_ATTACKS_WHITE[40], sq_to_bb(&[49]));
    }

    #[test]
    fn black_pawn_attack_table() {
        assert_eq!(PAWN_ATTACKS_BLACK[52], sq_to_bb(&[43, 45]));
        assert_eq!(PAWN_ATTACKS_BLACK[47], sq_to_bb(&[38]));
        assert_eq!(PAWN_ATTACKS_BLACK[29], sq_to_bb(&[20, 22]));
        assert_eq!(PAWN_ATTACKS_BLACK[24], sq_to_bb(&[17]));
        assert_eq!(PAWN_ATTACKS_BLACK[19], sq_to_bb(&[10, 12]));
    }

    #[test]
    fn knight_attack_table() {
        assert_eq!(KNIGHT_ATTACKS[0],  sq_to_bb(&[10, 17]));
        assert_eq!(KNIGHT_ATTACKS[1],  sq_to_bb(&[11, 16, 18]));
        assert_eq!(KNIGHT_ATTACKS[8],  sq_to_bb(&[2, 18, 25]));

        assert_eq!(KNIGHT_ATTACKS[6],  sq_to_bb(&[12, 21, 23]));
        assert_eq!(KNIGHT_ATTACKS[7],  sq_to_bb(&[13, 22]));
        assert_eq!(KNIGHT_ATTACKS[15], sq_to_bb(&[5, 21, 30]));

        assert_eq!(KNIGHT_ATTACKS[48], sq_to_bb(&[33, 42, 58]));
        assert_eq!(KNIGHT_ATTACKS[56], sq_to_bb(&[41, 50]));
        assert_eq!(KNIGHT_ATTACKS[57], sq_to_bb(&[40, 42, 51]));

        assert_eq!(KNIGHT_ATTACKS[55], sq_to_bb(&[38, 45, 61]));
        assert_eq!(KNIGHT_ATTACKS[62], sq_to_bb(&[45, 47, 52]));
        assert_eq!(KNIGHT_ATTACKS[63], sq_to_bb(&[46, 53]));

        assert_eq!(KNIGHT_ATTACKS[11], sq_to_bb(&[1, 5, 17, 21, 26, 28]));
        assert_eq!(KNIGHT_ATTACKS[25], sq_to_bb(&[8, 10, 19, 35, 40, 42]));
        assert_eq!(KNIGHT_ATTACKS[36], sq_to_bb(&[19, 21, 26, 30, 42, 46, 51, 53]));
    }

    #[test]
    fn king_attack_table() {
        assert_eq!(KING_ATTACKS[0],  sq_to_bb(&[1, 8, 9]));
        assert_eq!(KING_ATTACKS[7],  sq_to_bb(&[6, 14, 15])); 
        assert_eq!(KING_ATTACKS[56], sq_to_bb(&[48, 49, 57]));
        assert_eq!(KING_ATTACKS[63], sq_to_bb(&[54, 55, 62]));

        assert_eq!(KING_ATTACKS[3],  sq_to_bb(&[2, 4, 10, 11, 12]));
        assert_eq!(KING_ATTACKS[16], sq_to_bb(&[8, 9, 17, 24, 25]));
        assert_eq!(KING_ATTACKS[39], sq_to_bb(&[30, 31, 38, 46, 47]));
        assert_eq!(KING_ATTACKS[58], sq_to_bb(&[49, 50, 51, 57, 59]));

        assert_eq!(KING_ATTACKS[42], sq_to_bb(&[33, 34, 35, 41, 43, 49, 50, 51]));
        assert_eq!(KING_ATTACKS[19], sq_to_bb(&[10, 11, 12, 18, 20, 26, 27, 28]));
    }

    #[test]
    fn rook_masks() {
        assert_eq!(ROOK_MASKS[0],  (FILE_A | RANK[1]) & !sq_to_bb(&[0, 7, 56]));
        assert_eq!(ROOK_MASKS[3],  (FILE_D | RANK[1]) & !sq_to_bb(&[3, 0, 7, 59]));
        assert_eq!(ROOK_MASKS[9],  (FILE_B | RANK[2]) & !sq_to_bb(&[9, 8, 15, 1, 57]));
        assert_eq!(ROOK_MASKS[19], (FILE_D | RANK[3]) & !sq_to_bb(&[19, 16, 23, 3, 59]));
        assert_eq!(ROOK_MASKS[24], (FILE_A | RANK[4]) & !sq_to_bb(&[24, 0, 56, 31]));
        assert_eq!(ROOK_MASKS[38], (FILE_G | RANK[5]) & !sq_to_bb(&[38, 32, 39, 6, 62]));
        assert_eq!(ROOK_MASKS[55], (FILE_H | RANK[7]) & !sq_to_bb(&[55, 48, 7, 63]));
    }

    #[test]
    fn bishop_masks() {
        assert_eq!(BISHOP_MASKS[0],  sq_to_bb(&[9, 18, 27, 36, 45, 54]));
        assert_eq!(BISHOP_MASKS[3],  sq_to_bb(&[10, 17, 12, 21, 30]));
        assert_eq!(BISHOP_MASKS[13], sq_to_bb(&[20, 27, 34, 41, 22]));
        assert_eq!(BISHOP_MASKS[24], sq_to_bb(&[17, 10, 33, 42, 51]));
        assert_eq!(BISHOP_MASKS[38], sq_to_bb(&[29, 20, 11, 45, 52]));
        assert_eq!(BISHOP_MASKS[55], sq_to_bb(&[46, 37, 28, 19, 10]));
        assert_eq!(BISHOP_MASKS[56], sq_to_bb(&[49, 42, 35, 28, 21, 14]));
    }
}
